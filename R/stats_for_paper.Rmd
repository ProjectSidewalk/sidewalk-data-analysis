---
title: "Statistics for Paper"
author: "Mikey Saugstad"
date: "April 6, 2018"
output:
  github_document:
    toc: yes
  html_document:
    toc: yes
  
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
library(RPostgreSQL)
library(ggplot2)
library(tidyr)
library(dplyr)
library(forcats)
library(janitor)

# Run the following in console when you want to generate github flavored markdown as well.
# library(rmarkdown)
# render('R/stats_for_paper.Rmd', c('html_document', 'github_document'))

# If true, queries local postges database for data (could take a very long time), then saves in
# CSVs, so you should set to FALSE after running with the actual queries once.
REFRESH_PUBLIC_DEPLOYMENT_DATA = FALSE
REFRESH_TURK_STUDY_DATA = FALSE

LABEL_TYPE_MAPPING <- c(
  '1' = 'CurbRamp',
  '2' = 'NoCurbRamp',
  '3' = 'Obstacle',
  '4' = 'SurfaceProblem',
  '5' = 'Other',
  '6' = 'Occlusion',
  '7' = 'NoSidewalk'
)
TOTAL_STREET_DIST_METERS <- 1730179
TOTAL_STREET_DIST_MILES <- TOTAL_STREET_DIST_METERS / 1609.34

LABEL_TYPES_TO_ANALYZE = c('All', 'Problem', 'CurbRamp', 'NoCurbRamp', 'Obstacle', 'SurfaceProb')

# Variables commonly used in plotting
my.theme.discrete.x <- theme_bw() + theme(panel.grid.major.x = element_blank())
ACCURACY_BREAKS <- c(0, 0.25, 0.5, 0.75, 1.0)
```

```{r connect, echo=FALSE}
if (REFRESH_PUBLIC_DEPLOYMENT_DATA | REFRESH_TURK_STUDY_DATA) drv <- dbDriver("PostgreSQL")
if (REFRESH_PUBLIC_DEPLOYMENT_DATA) {
  db.connection.public.deployment <- dbConnect(drv, dbname = "sidewalk",
                   host = "localhost", port = 5432,
                   user = "sidewalk", password = 'sidewalk')
}
if (REFRESH_TURK_STUDY_DATA) {
  db.connection.turk.study <- dbConnect(drv, dbname = "sidewalkturk",
                   host = "localhost", port = 5432,
                   user = "sidewalk", password = 'sidewalk')
  db.connection.turk.study.production <- dbConnect(drv, dbname = "production-gt",
                   host = "localhost", port = 5432,
                   user = "sidewalk", password = 'sidewalk')
}
```


```{r reading.data, echo=FALSE, include=FALSE}
if (REFRESH_PUBLIC_DEPLOYMENT_DATA) {
  reg.labels <-
    dbGetQuery(
      db.connection.public.deployment,
      'SELECT label_id, user_role.user_id, role.role, label_type_id, audit_task.audit_task_id
      FROM role
      INNER JOIN user_role ON role.role_id = user_role.role_id
      INNER JOIN audit_task ON user_role.user_id = audit_task.user_id
      INNER JOIN label ON audit_task.audit_task_id = label.audit_task_id
      WHERE label.deleted = FALSE
      AND user_role.user_id <> \'97760883-8ef0-4309-9a5e-0c086ef27573\''
      )
  anon.labels <-
    dbGetQuery(
      db.connection.public.deployment,
      'SELECT DISTINCT label_id,
                       ip_address AS user_id,
                       \'Anonymous\' AS role,
                       label_type_id,
                       audit_task.audit_task_id
      FROM audit_task
      INNER JOIN label ON audit_task.audit_task_id = label.audit_task_id
      INNER JOIN audit_task_environment
          ON audit_task.audit_task_id = audit_task_environment.audit_task_id
      WHERE label.deleted = FALSE
      AND user_id = \'97760883-8ef0-4309-9a5e-0c086ef27573\''
      )
  reg.audits <-
    dbGetQuery(
      db.connection.public.deployment,
      'SELECT audit_task.user_id, role.role, audit_task.audit_task_id,
              street_edge.street_edge_id,
              ST_LENGTH(ST_TRANSFORM(geom,26918)) * 3.28084 AS feet_audited
      FROM street_edge
      INNER JOIN audit_task
      ON street_edge.street_edge_id = audit_task.street_edge_id
      INNER JOIN user_role
      ON audit_task.user_id = user_role.user_id
      INNER JOIN role
      ON user_role.role_id = role.role_id
      WHERE street_edge.deleted = FALSE
      AND audit_task.user_id <> \'97760883-8ef0-4309-9a5e-0c086ef27573\'
      AND completed = TRUE'
      )
  anon.audits <-
    dbGetQuery(
      db.connection.public.deployment,
      'SELECT DISTINCT ip_address AS user_id, \'Anonymous\' AS role, audit_task.audit_task_id,
              street_edge.street_edge_id,
              ST_LENGTH(ST_TRANSFORM(geom,26918)) * 3.28084 AS feet_audited
      FROM street_edge
      INNER JOIN audit_task
      ON street_edge.street_edge_id = audit_task.street_edge_id
      INNER JOIN audit_task_environment
      ON audit_task.audit_task_id = audit_task_environment.audit_task_id
      WHERE street_edge.deleted = FALSE
      AND user_id = \'97760883-8ef0-4309-9a5e-0c086ef27573\'
      AND completed = TRUE'
      )
  reg.times <-
    dbGetQuery(
      db.connection.public.deployment,
      'SELECT user_audit_times.user_id,
             CAST(extract( second from SUM(diff) ) / 60 +
                  extract( minute from SUM(diff) ) +
                  extract( hour from SUM(diff) ) * 60 AS decimal(10,2)) AS minutes_audited
      FROM
      (
          SELECT audit_task.user_id,
                 (timestamp - LAG(timestamp, 1) OVER(PARTITION BY user_id ORDER BY timestamp)) AS diff
          FROM audit_task_interaction
          INNER JOIN audit_task ON audit_task.audit_task_id = audit_task_interaction.audit_task_id
          WHERE action = \'ViewControl_MouseDown\'
              AND audit_task.user_id <> \'97760883-8ef0-4309-9a5e-0c086ef27573\'
          ) user_audit_times
      WHERE diff < \'00:05:00.000\' AND diff > \'00:00:00.000\'
      GROUP BY user_audit_times.user_id;'
      )
  anon.times <-
    dbGetQuery(
      db.connection.public.deployment,
      'SELECT user_audit_times.ip_address AS user_id,
             CAST(extract( second from SUM(diff) ) / 60 +
                  extract( minute from SUM(diff) ) +
                  extract( hour from SUM(diff) ) * 60 AS decimal(10,2)) AS minutes_audited
      FROM
      (
          SELECT  user_id, ip_address,
                  (
                      timestamp - Lag(timestamp, 1)
                      OVER(PARTITION BY ip_address ORDER BY timestamp)
                  ) AS diff
          FROM audit_task_interaction
          INNER JOIN audit_task ON audit_task.audit_task_id = audit_task_interaction.audit_task_id
          INNER JOIN audit_task_environment
              ON audit_task.audit_task_id = audit_task_environment.audit_task_id
          WHERE action = \'ViewControl_MouseDown\'
          AND audit_task.user_id = \'97760883-8ef0-4309-9a5e-0c086ef27573\'
          AND ip_address IN
          (
              SELECT ip_address
              FROM audit_task_environment
              INNER JOIN audit_task
                  ON audit_task.audit_task_id = audit_task_environment.audit_task_id
              WHERE completed = true
          )
      ) user_audit_times
      WHERE diff < \'00:05:00.000\' AND diff > \'00:00:00.000\'
      GROUP BY ip_address;'
      )
  reg.sessions <-
    dbGetQuery(
      db.connection.public.deployment,
      'SELECT "user".user_id, 1 + COALESCE(n_sessions_minus_one, 0) AS n_sessions
      FROM
      (
          SELECT user_audit_times.user_id, COUNT(diff) AS n_sessions_minus_one
          FROM
          (
              SELECT  audit_task.user_id,
                      (
                          timestamp - LAG(timestamp, 1)
                          OVER(PARTITION BY user_id ORDER BY timestamp)
                      ) AS diff
              FROM audit_task_interaction
              INNER JOIN audit_task
                  ON audit_task.audit_task_id = audit_task_interaction.audit_task_id
              WHERE action = \'ViewControl_MouseDown\'
                  AND audit_task.user_id <> \'97760883-8ef0-4309-9a5e-0c086ef27573\'
          ) user_audit_times
          WHERE diff > \'01:00:00.000\'
          GROUP BY user_audit_times.user_id
      ) sess_counts
      RIGHT JOIN "user" ON sess_counts.user_id = "user".user_id;'
      )
  anon.sessions <-
    dbGetQuery(
      db.connection.public.deployment,
      'SELECT ips.ip_address AS user_id, 1 + COALESCE(n_sessions_minus_one, 0) AS n_sessions
      FROM
      (
          SELECT DISTINCT(ip_address) FROM audit_task_environment
      ) ips
      LEFT JOIN
      (
          SELECT user_audit_times.ip_address, COUNT(diff) AS n_sessions_minus_one
          FROM
          (
              SELECT  user_id,
                      ip_address,
                      (
                      timestamp - Lag(timestamp, 1)
                      OVER(PARTITION BY user_id ORDER BY timestamp)
                      ) AS diff
              FROM audit_task_interaction
              INNER JOIN audit_task
                  ON audit_task.audit_task_id = audit_task_interaction.audit_task_id
              INNER JOIN audit_task_environment
                  ON audit_task.audit_task_id = audit_task_environment.audit_task_id
              WHERE action = \'ViewControl_MouseDown\'
              AND audit_task.user_id = \'97760883-8ef0-4309-9a5e-0c086ef27573\'
              AND ip_address IN
              (
                  SELECT ip_address
                  FROM audit_task_environment
                  INNER JOIN audit_task
                      ON audit_task.audit_task_id = audit_task_environment.audit_task_id
                  WHERE completed = true
              )
          ) user_audit_times
          WHERE diff > \'01:00:00.000\'
          GROUP BY ip_address
      ) sess_counts
      ON ips.ip_address = sess_counts.ip_address;'
      )
  reg.missions <-
    dbGetQuery(
      db.connection.public.deployment,
      'SELECT "user".user_id, COALESCE(count, 0) AS mission_count
      FROM "user"
      LEFT JOIN
      (
        SELECT "user".user_id, COUNT(mission_user_id)
        FROM "user"
        INNER JOIN mission_user
        ON "user".user_id = mission_user.user_id
        GROUP BY "user".user_id
      ) "nonzero_counts"
      ON nonzero_counts.user_id = "user".user_id
      WHERE "user".user_id <> \'97760883-8ef0-4309-9a5e-0c086ef27573\''
      )
  dbDisconnect(db.connection.public.deployment)
  
  audits <- bind_rows(reg.audits, anon.audits)
  times <- bind_rows(reg.times, anon.times)
  labels <- bind_rows(reg.labels, anon.labels)
  sessions <- bind_rows(reg.sessions, anon.sessions)
  write.csv(audits, '../data/stats_for_paper_audits.csv', row.names = FALSE)
  write.csv(times, '../data/stats_for_paper_times.csv', row.names = FALSE)
  write.csv(labels, '../data/stats_for_paper_labels.csv', row.names = FALSE)
  write.csv(sessions, '../data/stats_for_paper_sessions.csv', row.names = FALSE)
  write.csv(reg.missions, '../data/stats_for_paper_reg_missions.csv', row.names = FALSE)
} else {
  audit.classes <- c('character', 'character', 'numeric', 'numeric', 'numeric')
  audits <- read.csv('../data/stats_for_paper_audits.csv', colClasses = audit.classes)
  time.classes <- c('character', 'numeric')
  times <- read.csv('../data/stats_for_paper_times.csv', colClasses = time.classes)
  label.classes <- c('numeric', 'character', 'character', 'numeric', 'numeric')
  labels <- read.csv('../data/stats_for_paper_labels.csv', colClasses = label.classes)
  session.classes <- c('character', 'numeric')
  sessions <- read.csv('../data/stats_for_paper_sessions.csv', colClasses = session.classes)
  mission.classes <- c('character', 'numeric')
  reg.missions <- read.csv('../data/stats_for_paper_reg_missions.csv', colClasses = mission.classes)
}


if (REFRESH_TURK_STUDY_DATA) {
  reg.labels.turk.study <-
    dbGetQuery(
      db.connection.turk.study.production,
      'SELECT label_id, user_id, label_type_id, audit_task.audit_task_id, amt_condition_id AS condition_id
      FROM amt_condition
      INNER JOIN amt_volunteer_route ON amt_condition.volunteer_id = amt_volunteer_route.volunteer_id
      INNER JOIN route_street ON amt_volunteer_route.route_id = route_street.route_id
      INNER JOIN audit_task ON  route_street.current_street_edge_id = audit_task.street_edge_id
                            AND amt_volunteer_route.volunteer_id = audit_task.user_id
      INNER JOIN label ON audit_task.audit_task_id = label.audit_task_id
      WHERE amt_condition.amt_condition_id NOT IN (71, 104, 123, 124, 138)
      AND label.deleted <> TRUE'
      )
  anon.labels.turk.study <-
    dbGetQuery(
      db.connection.turk.study.production,
      'SELECT DISTINCT label_id, audit_task_environment.ip_address AS user_id, label_type_id,
                       audit_task.audit_task_id, amt_condition_id AS condition_id
      FROM amt_condition
      INNER JOIN amt_volunteer_route
          ON amt_condition.volunteer_id = amt_volunteer_route.volunteer_id
      INNER JOIN route_street ON amt_volunteer_route.route_id = route_street.route_id
      INNER JOIN audit_task
          ON  route_street.current_street_edge_id = audit_task.street_edge_id
      INNER JOIN audit_task_environment
          ON  audit_task.audit_task_id = audit_task_environment.audit_task_id
          AND amt_volunteer_route.ip_address = audit_task_environment.ip_address
      INNER JOIN label ON audit_task.audit_task_id = label.audit_task_id
      WHERE amt_condition.amt_condition_id NOT IN (71, 104, 123, 124, 138)
      AND label.deleted <> TRUE'
      )
  turk.labels.turk.study <-
    dbGetQuery(
      db.connection.turk.study,
      'SELECT label_id, turker_id AS user_id, label_type_id, audit_task.audit_task_id, condition_id
      FROM amt_assignment
      INNER JOIN audit_task ON amt_assignment.amt_assignment_id = audit_task.amt_assignment_id
      INNER JOIN label ON audit_task.audit_task_id = label.audit_task_id
      WHERE amt_assignment.condition_id NOT IN (71, 104, 123, 124, 138)
      AND label.deleted <> TRUE'
      )
  reg.times.turk.study <-
    dbGetQuery(
      db.connection.turk.study.production,
      'SELECT user_audit_times.user_id,
             CAST(extract( second from SUM(diff) ) / 60 +
                  extract( minute from SUM(diff) ) +
                  extract( hour from SUM(diff) ) * 60 AS decimal(10,2)) AS minutes_audited
      FROM
      (
          SELECT audit_task.user_id,
                 (
                     timestamp - LAG(timestamp, 1)
                     OVER(PARTITION BY user_id ORDER BY timestamp)
                 ) AS diff
          FROM amt_condition
          INNER JOIN amt_volunteer_route
              ON amt_condition.volunteer_id = amt_volunteer_route.volunteer_id
          INNER JOIN route_street ON amt_volunteer_route.route_id = route_street.route_id
          INNER JOIN audit_task
              ON route_street.current_street_edge_id = audit_task.street_edge_id
              AND amt_volunteer_route.volunteer_id = audit_task.user_id
          INNER JOIN audit_task_interaction
              ON audit_task.audit_task_id = audit_task_interaction.audit_task_id
          WHERE action = \'ViewControl_MouseDown\'
              AND amt_condition_id NOT IN (71, 104, 123, 124, 138)
          ) user_audit_times
      WHERE diff < \'00:05:00.000\' AND diff > \'00:00:00.000\'
      GROUP BY user_audit_times.user_id;'
      )
  anon.times.turk.study <-
    dbGetQuery(
      db.connection.turk.study.production,
      'SELECT user_audit_times.user_id,
             CAST(extract( second from SUM(diff) ) / 60 +
                  extract( minute from SUM(diff) ) +
                  extract( hour from SUM(diff) ) * 60 AS decimal(10,2)) AS minutes_audited
      FROM
      (
          SELECT amt_volunteer_route.ip_address AS user_id,
                 (
                     timestamp - LAG(timestamp, 1)
                     OVER(PARTITION BY amt_volunteer_route.ip_address ORDER BY timestamp)
                 ) AS diff
          FROM amt_condition
          INNER JOIN amt_volunteer_route
              ON amt_condition.volunteer_id = amt_volunteer_route.volunteer_id
          INNER JOIN route_street ON amt_volunteer_route.route_id = route_street.route_id
          INNER JOIN audit_task ON route_street.current_street_edge_id = audit_task.street_edge_id
          INNER JOIN audit_task_environment
              ON  audit_task.audit_task_id = audit_task_environment.audit_task_id
              AND amt_volunteer_route.ip_address = audit_task_environment.ip_address
          INNER JOIN audit_task_interaction
              ON audit_task.audit_task_id = audit_task_interaction.audit_task_id
          WHERE action = \'ViewControl_MouseDown\'
              AND amt_condition_id NOT IN (71, 104, 123, 124, 138)
          ) user_audit_times
      WHERE diff < \'00:05:00.000\' AND diff > \'00:00:00.000\'
      GROUP BY user_audit_times.user_id;'
      )
  turk.times.turk.study <-
    dbGetQuery(
      db.connection.turk.study,
      'SELECT user_audit_times.user_id,
             CAST(extract( second from SUM(diff) ) / 60 +
                  extract( minute from SUM(diff) ) +
                  extract( hour from SUM(diff) ) * 60 AS decimal(10,2)) AS minutes_audited
      FROM
      (
          SELECT turker_id AS user_id,
                 (timestamp - LAG(timestamp, 1) OVER(PARTITION BY turker_id ORDER BY timestamp)) AS diff
          FROM amt_assignment
          INNER JOIN audit_task ON amt_assignment.amt_assignment_id = audit_task.amt_assignment_id
          INNER JOIN audit_task_interaction ON audit_task.audit_task_id = audit_task_interaction.audit_task_id
          WHERE action = \'ViewControl_MouseDown\'
              AND condition_id NOT IN (71, 104, 123, 124, 138)
          ) user_audit_times
      WHERE diff < \'00:05:00.000\' AND diff > \'00:00:00.000\'
      GROUP BY user_audit_times.user_id;'
      )
  dbDisconnect(db.connection.turk.study.production)
  dbDisconnect(db.connection.turk.study)
  
  # audits.turk.study <- bind_rows(reg.audits.turk.study, anon.audits.turk.study, turk.audits.turk.study)
  times.turk.study <- bind_rows(reg.times.turk.study, anon.times.turk.study, turk.times.turk.study)
  labels.turk.study <- bind_rows(reg.labels.turk.study, anon.labels.turk.study, turk.labels.turk.study)
  # sessions.turk.study <- bind_rows(reg.sessions.turk.study, anon.sessions.turk.study, turk.sessions.turk.study)
  # write.csv(audits.turk.study, '../data/stats_for_paper_audits-turk_study.csv', row.names = FALSE)
  write.csv(times.turk.study, '../data/stats_for_paper_times-turk_study.csv', row.names = FALSE)
  write.csv(labels.turk.study, '../data/stats_for_paper_labels-turk_study.csv', row.names = FALSE)
  # write.csv(sessions.turk.study, '../data/stats_for_paper_sessions-turk_study.csv', row.names = FALSE)
} else {
  # audit.classes.turk.study <- c('character', 'character', 'numeric', 'numeric', 'numeric')
  # audits.turk.study <- read.csv('../data/stats_for_paper_audits-turk_study.csv',
  #                               colClasses = audit.classes.turk.study)
  time.classes.turk.study <- c('character', 'numeric')
  times.turk.study <- read.csv('../data/stats_for_paper_times-turk_study.csv',
                               colClasses = time.classes.turk.study)
  label.classes.turk.study <- c('numeric', 'character', 'numeric', 'numeric', 'numeric')
  labels.turk.study <- read.csv('../data/stats_for_paper_labels-turk_study.csv',
                                colClasses = label.classes.turk.study)
  # session.classes.turk.study <- c('character', 'numeric')
  # sessions.turk.study <- read.csv('../data/stats_for_paper_sessions-turk_study.csv',
  #                                 colClasses = session.classes.turk.study)
}

zoning.classes <- c('numeric', 'numeric', 'numeric', 'factor', 'factor', 'logical')
zoning.data <- read.csv('../data/street_zoning_info.csv', colClasses = zoning.classes) %>%
  dplyr::rename(condition.id = condition_id)
```

```{r transforming.data, echo=FALSE, warning=FALSE}
# Takes a distance in feet and approximates the number of missions the user completed. The
# approximation assumes that the first missions are 500, 500, 1000, 2000, and 1280 feet, and all the
# remaining missions are half a mile (2640 feet).
approximate.missions.completed <- Vectorize(
  function(dist.in.feet) {
    if (dist.in.feet > 7920) 5 + floor((dist.in.feet - 5280) / 2640)
    else if (dist.in.feet > 5280) 5
    else if (dist.in.feet > 4000) 4
    else if (dist.in.feet > 2000) 3
    else if (dist.in.feet > 1000) 2
    else if (dist.in.feet > 500) 1
    else 0
  }
)

# Computes minutes_per_mission as either minutes_audited / missions_completed if at least one
# mission was completed, other wise 500 * minutes_audited / feet_audited (how long the first mission
# would take, given the auditing speed for what they had done)
approximate.minutes.per.mission <- Vectorize(
  function(time.audited, missions.completed, dist.in.feet) {
    if (missions.completed > 0) time.audited / missions.completed
    else 500 * time.audited / dist.in.feet
  }
)

label.counts <-
  labels %>%
  # filter(label_type_id != 7) %>%
  group_by(user_id) %>%
  dplyr::summarize(label_count = n_distinct(label_id), role = first(role))

# Selects distinct on audit_task_id, then sums dist audited.
audit.length <-
  audits %>%
  group_by(user_id, role) %>%
  distinct(audit_task_id, .keep_all = TRUE) %>%
  dplyr::summarise(feet_audited = sum(feet_audited), audit_count = n()) %>%
  ungroup() %>%
  mutate(miles_audited = feet_audited / 5280) %>%
  left_join(label.counts, by = c('user_id', 'role')) %>%
  replace_na(list(label_count = 0)) %>%
  left_join(sessions, by = 'user_id') %>%
  mutate(role = factor(role)) %>%
  mutate(role = recode(role, User = 'Registered', .default = levels(role))) %>%
  mutate(labels_per_100m = 328.084 * label_count / feet_audited)

# Computes approximate missions completed for anon users.
all.mission.counts <-
  audit.length %>%
  filter(role == "Anonymous") %>%
  mutate(mission_count = approximate.missions.completed(feet_audited)) %>%
  select(user_id, mission_count) %>%
  bind_rows(reg.missions)

# Computes a few metrics based on distance audited, time auditing, and missions completed.
speeds <-
  audit.length %>%
  left_join(all.mission.counts, by = 'user_id') %>%
  left_join(times, by = 'user_id') %>%
  mutate(feet_per_min = feet_audited / minutes_audited,
         meters_audited = feet_audited / 3.28084,
         m_per_min = meters_audited / minutes_audited,
         km_per_hr = 60 * m_per_min / 1000,
         minutes_per_mission = approximate.minutes.per.mission(minutes_audited, mission_count, feet_audited),
         minutes_per_1k_ft = 1000 * minutes_audited / feet_audited,
         hours_audited = minutes_audited / 60,
         minutes_per_session = minutes_audited / n_sessions)

filtered.speeds <-
  speeds %>%
  filter(role %in% c('Registered', 'Anonymous', 'Turker'),
         labels_per_100m >= 3.75)
```

# Public Deployment

NOTE: Public deployment data includes all data up through March 31st (and part of April 1st). This includes all data through the most recent deployment on mturk.

## High-level results

### Top-line numbers (no filtering)

TODO: Decide how to cluster production labels

The following are the label counts (not issue counts) by user group and label type.

```{r public.deployment.how.much.data, echo=FALSE, warning=FALSE}
ordered.label.type.levs <- c('CurbRamp', 'NoCurbRamp', 'Obstacle', 'SurfaceProblem', 'NoSidewalk',
                             'Occlusion', 'Other')
kable(
  labels %>%
    distinct(label_id, .keep_all = TRUE) %>%
    mutate(label_type = LABEL_TYPE_MAPPING[label_type_id]) %>%
    mutate(label_type = factor(label_type, ordered.label.type.levs)) %>%
    mutate(role = recode_factor(role,
                                `Anonymous` = 'Anon',
                                `User` = 'Registered',
                                `Turker` = 'Turker',
                                `Administrator` = 'Researcher',
                                `Owner` = 'Researcher')) %>%
    select(label_type, role) %>%
    tabyl(label_type, role) %>%
    adorn_totals(where = c('row', 'col')) %>%
    adorn_percentages(denominator = 'all') %>%
    adorn_pct_formatting() %>%
    adorn_ns(position = 'front'),
  align = 'l'
)
```

### Data characteristics

This is the start of filtering out users with low labeling frequency (also filtering out researchers).

```{r public.deployment.data.characteristics, echo=FALSE, warning=FALSE}
filtered.labels <- filter(labels, user_id %in% filtered.speeds$user_id)
kable(
  filtered.labels %>%
    distinct(label_id, .keep_all = TRUE) %>%
    count(label_type_id) %>%
    mutate(label_type = LABEL_TYPE_MAPPING[label_type_id]) %>%
    select(label_type, n) %>%
    bind_rows(list(label_type = 'Total', n = n_distinct(filtered.labels$label_id))) %>%
    spread(label_type, n),
  align = 'l'
)

filtered.audits <- filter(audits, user_id %in% filtered.speeds$user_id)
n.audits <- nrow(filtered.audits)
n.streets <- n_distinct(filtered.audits$street_edge_id)
```

There have been a total of `r n.audits` audits by our users across `r n.streets` streets, averaging `r format(n.audits/n.streets, digits = 3)` audits per street.

### User stats and tool usage

TODO: Missions started vs missions completed (not sure we can do this; I expect it to be difficult, without much benefit).

Below are the medians for a few metrics (followed by sums), split by user group. For all user groups, the minimum threshold to be included in this list was that they have completed at least one audit task and that their labeling threshold is above 3.75 labels per 100 meters.

NOTE: A "session" below is defined as a sequence of audit task interactions for a user where the minimum time between consecutive interactions is less than one hour.

```{r public.deployment.showing.stats, echo=FALSE, warning=FALSE}
kable(
  filtered.speeds %>%
    group_by(role) %>%
    dplyr::summarise(
      n_users = n(),
      miles = median(miles_audited, na.rm = TRUE),
      km = median(meters_audited / 1000, na.rm = TRUE),
      missions = median(mission_count, na.rm = TRUE),
      audits = median(audit_count, na.rm = TRUE),
      minutes_audited = median(minutes_audited, na.rm = TRUE),
      km_per_hr = median(km_per_hr, na.rm = TRUE),
      m_per_min = median(m_per_min, na.rm = TRUE),
      minutes_per_1k_ft = median(minutes_per_1k_ft, na.rm = TRUE),
      labels = median(label_count, na.rm = TRUE),
      labels_per_100m = median(labels_per_100m, na.rm = TRUE),
      sessions = median(n_sessions, na.rm = TRUE),
      mins_per_sess = median(minutes_per_session, na.rm = TRUE)
      ),
  digits = 3,
  align = 'l'
  )

kable(
  filtered.speeds %>%
    group_by(role) %>%
    dplyr::summarise(
      n_users = n(),
      miles = sum(miles_audited, na.rm = TRUE),
      km = sum(meters_audited / 1000, na.rm = TRUE),
      coverage = paste0(format(100 * sum(miles_audited, na.rm = TRUE) / TOTAL_STREET_DIST_MILES,
                               digits = 2),
                        '%'),
      missions = sum(mission_count, na.rm = TRUE),
      audits = sum(audit_count, na.rm = TRUE),
      hours_audited = sum(hours_audited, na.rm = TRUE),
      labels = sum(label_count, na.rm = TRUE),
      '>1 sess' = paste0(format(100 * sum(n_sessions > 1) / n(), digits = 2), '%')
      ),
  digits = 0,
  align = 'l'
  )
```


## Possible Stories

### Data overlap and agreement between users

Among all the data collected in DC, how much of DC is labeled by multiple users and what is the disagreement among them? (see comment in Outline document for details on implementation)


### Stickyness of tool: user dropoffs

We want a bar chart here showing, after a user clicks start mapping, what percentage finish the tutorial, what percentage finish a mission, etc.


# Turk Study

Update: This is now all of the data. There used to be 19 anonymous user routes, but three of them actually had no labels placed by the anonymous user (we had forgotten to check beforehand), thus we have only 16.

Even though 5 turkers did each route, the high level results for individual turkers looks only at the first turker to complete each set of routes. This makes aggregate stats more even, and a fairer comparison across user groups. (but maybe we should actually use all turkers when not aggregating, actually...)

## High level results

```{r turk.reading.cleaning.data, echo=FALSE, include=FALSE}
# Get conditions to exclude
zoning.data %>% filter(exclude) %>% distinct(condition_id)

# Get IRR data
agreement.classes <- c('numeric', 'factor', 'factor', 'factor', 'numeric', 'numeric')
agreement.data <- read.csv('../data/irr_results-not_for_humans.csv', colClasses = agreement.classes)

label.type.levels.in.order <- c('CurbRamp','NoCurbRamp','Obstacle','SurfaceProb','Problem')
clean.agreement.data <-
  agreement.data %>%
  mutate(label.type = case_when(
            data.type %in% c('prob.binary', 'prob.ordinal') ~ 'Problem',
            label.type == 'SurfaceProblem'                  ~ 'SurfaceProb',
            TRUE                                            ~ as.character(label.type)
          ),
         data.type = if_else(data.type %in% c('prob.binary', 'binary'),
                             'binary',
                             'ordinal')) %>%
  filter(level == 'street',
         data.type == 'binary',
         label.type %in% c('CurbRamp', 'NoCurbRamp', 'Obstacle', 'SurfaceProb', 'Problem')) %>%
  mutate(data.type = factor(data.type),
         level = factor(level),
         label.type = factor(label.type, label.type.levels.in.order))


# Get accuracy data
classes <- c('numeric', replicate(5, 'character'), 'numeric', 'numeric', 'logical', 'character',
             'factor', 'character', replicate(8, 'numeric'))
volunteer.data <- read.csv('../data/accuracies-volunteer.csv',
                           colClasses = classes,
                           na.strings = c('null')) %>%
  mutate(is.turker = FALSE)
turker.data <- read.csv('../data/accuracies-turker.csv',
                        colClasses = classes,
                        na.strings = c('null')) %>%
  mutate(is.turker = TRUE)

# Combine datasets
accuracy.data <- rbind(volunteer.data, turker.data)

# Create data for summing true/false pos/neg over all label types, and all problem label types.
# First summing over curb ramp, missing curb ramp, obstacle, and surface problem...
all.types.data <-
  accuracy.data %>%
  filter(label.type %in% c('CurbRamp', 'NoCurbRamp', 'Obstacle', 'SurfaceProblem')) %>%
  group_by(condition.id, worker1, worker2, worker3, worker4, worker5, n.workers, worker.thresh,
           binary, included.severity, granularity, is.turker) %>%
  dplyr::summarize(label.type = 'All',
                   true.pos = sum(true.pos),
                   false.pos = sum(false.pos),
                   true.neg = sum(true.neg),
                   false.neg = sum(false.neg)) %>%
  ungroup()

# Then summing over just missing curb ramp, obstacle, and surface problem...
problem.types.data <-
  accuracy.data %>%
  filter(label.type %in% c('NoCurbRamp', 'Obstacle', 'SurfaceProblem')) %>%
  group_by(condition.id, worker1, worker2, worker3, worker4, worker5, n.workers, worker.thresh,
           binary, included.severity, granularity, is.turker) %>%
  dplyr::summarize(label.type = 'AllProb',
                   true.pos = sum(true.pos),
                   false.pos = sum(false.pos),
                   true.neg = sum(true.neg),
                   false.neg = sum(false.neg)) %>%
  ungroup()

# Now we combine them and compute the accuracy metrics for each row, and attach to main dataset.
data.with.agg.types <-
  all.types.data %>%
  bind_rows(problem.types.data) %>%
  mutate(precision = true.pos / (true.pos + false.pos),
         recall = true.pos / (true.pos + false.neg),
         specificity = true.neg / (true.neg + false.pos),
         f.measure = 2 * (precision * recall) / (precision + recall)) %>%
  bind_rows(accuracy.data)

# Remove occlusion and other label types, rename SurfaceProblem label type as SurfaceProb for
# easier visualization and set order of factor levels.
label.types <- c('All', 'Problem', 'CurbRamp', 'NoCurbRamp', 'Obstacle', 'SurfaceProb', 'NoSidewalk', 'AllProb')
data.filtered.label.type <-
  data.with.agg.types %>%
  mutate(label.type = if_else(label.type == 'SurfaceProblem', 'SurfaceProb', label.type)) %>%
  filter(label.type %in% label.types) %>%
  mutate(label.type = factor(label.type, levels = label.types, labels = label.types))

# More setup: remove binary analysis (except street level), add is.anon.route column, add
#             raw.accuracy column, add worker.type column, give granularity an ordering.
get.worker.type <- Vectorize(
  function(n.workers, worker.thresh, is.turker, is.anon.route) {
    if (n.workers == 5 & worker.thresh == 3) 'turk5'
    else if (n.workers == 3 & worker.thresh == 2) 'turk3'
    else if (n.workers == 1 & is.turker == TRUE) 'turk1'
    else if (is.turker == TRUE) 'turk0' # probably aren't analyzing any other turkers
    else if (is.anon.route == TRUE) 'anon'
    else 'reg'
  }
)
# The user.id column has the user id for reg and turk users, but for anon they are of the form
# '<anon.user.id>---<ip.address>'. Since the anon user id is the same for everyone, we just want the
# ip address. So this function splits on '---' (which only occurs for anon users), reverses the
# output of the split (meaning no ip address is now first in output list for anon users, and no
# change for other users, since the list is of length one), then takes first element of that list.
fix.anon.names <- Vectorize(
  function(user.id) {
    rev(strsplit(user.id, '---', fixed = TRUE)[[1]])[1]
  }
)
  
data.with.raw.accuracy <-
  data.filtered.label.type %>%
  filter(granularity != '10_meter') %>%
  mutate(is.anon.route = condition.id > 121) %>%
  mutate(worker.type = factor(get.worker.type(n.workers, worker.thresh, is.turker, is.anon.route),
                              levels = c('anon', 'reg', 'turk1', 'turk3', 'turk5', 'turk0'))) %>%
  mutate(worker1 = fix.anon.names(worker1)) %>%
  mutate(raw.accuracy = (true.pos + true.neg) / (true.pos + true.neg + false.pos + false.neg)) %>%
  mutate(granularity = factor(granularity,
                              levels = c('street', '5_meter'),
                              labels = c('street', '5_meter'))) %>%
  filter(label.type != 'NoSidewalk' | (granularity == 'street' & binary == TRUE))
```

TODO: Come up with our own zone type descriptions, possibly aggregating as well. <br>
TODO: Add "n" to a bunch of graphs. <br>
TODO: Percentage of turkers who completed the HIT (maybe?).

### Ground truth label counts

```{r turk.high.level.results, echo=FALSE, include=FALSE}
unique.turkers <-
  data.with.raw.accuracy %>%
  filter(worker.type == 'turk5',
         binary == FALSE,
         included.severity == 'all',
         granularity == 'street',
         label.type == 'CurbRamp') %>%
  select(worker1, worker2, worker3, worker4, worker5) %>%
  gather(worker.index, turker.id) %>%
  select(turker.id)

n.turkers <- nrow(unique.turkers)
n.reg <- n_distinct(data.with.raw.accuracy %>% filter(!is.turker, !is.anon.route) %>% select(worker1))
n.anon <- n_distinct(data.with.raw.accuracy %>% filter(!is.turker, is.anon.route) %>% select(worker1))

aggregate.accuracy.data <-
  data.with.raw.accuracy %>%
  filter(n.workers == 1,
         binary == TRUE,
         included.severity == 'all',
         label.type %in% c('All', 'Problem')) %>%
  select_at(vars(label.type, granularity, recall, precision, f.measure)) %>%
  group_by(label.type, granularity) %>%
  summarize_at(vars(recall, precision, f.measure), median, na.rm = TRUE) %>%
  ungroup()

# We filter down to the data we care about, then in the group_by we get down to 2 entries per group;
# one entry for the All type and one entry for the Problem type. We want to combine those into one
# row with columns all.recall, all.precision, prob.recall, prob.precision, etc. So while they are
# grouped, we create each of those new columns. We fill in the all.* columns in correctly in the
# "All" label type rows, putting NaN in the "Problem" rows. Vice versa for the prob.* columns. Then
# to actually combine these two rows we take the sum (where NA is treated as 0 in the sum). But b/c
# NA is treated as 0, this doesn't work when the value that was _supposed_ to be there is NA also!
# So we use an if_else to set to NA if both are NA, and take the some o/w.
turk.study.summary.stats <-
  data.with.raw.accuracy %>%
  filter(worker.type != 'turk0',
         binary == TRUE,
         included.severity == 'all',
         label.type %in% c('All', 'Problem')) %>%
  group_by(condition.id, worker1, is.anon.route, worker.type, granularity) %>%
  mutate(all.recall = if_else(label.type == 'All', recall, NaN),
         all.precision = if_else(label.type == 'All', precision, NaN),
         all.f.measure = if_else(label.type == 'All', f.measure, NaN),
         prob.recall = if_else(label.type == 'Problem', recall, NaN),
         prob.precision = if_else(label.type == 'Problem', precision, NaN),
         prob.f.measure = if_else(label.type == 'Problem', f.measure, NaN)) %>%
  summarize_at(vars(all.recall:prob.f.measure),
               function(x) { if_else(length(na.omit(x)) > 0, sum(x, na.rm = TRUE), NaN) }) %>%
  ungroup()

turk.study.summary.stats.with.labels <-
  turk.study.summary.stats %>%
  filter(worker.type %in% c('anon', 'reg', 'turk1')) %>%
  left_join(labels.turk.study, by = c('worker1' = 'user_id', 'condition.id' = 'condition_id')) %>%
  group_by_at(vars(worker1:prob.f.measure)) %>%
  dplyr::summarise(n.labels = n_distinct(label_id, na.rm = TRUE)) %>%
  left_join(times.turk.study, by = c('worker1' = 'user_id')) %>%
  mutate(n.missions = if_else(is.anon.route, 2, 3),
         distance.feet = if_else(is.anon.route, 2000, 4000),
         distance.meters = distance.feet / 3.28084,
         labels.per.100m = 100 * n.labels / distance.meters,
         meters.per.min = distance.meters / minutes_audited,
         km.per.hr = 60 * meters.per.min / 1000,
         minutes.per.1k.ft = 1000 * minutes_audited / distance.feet,
         hours.audited = minutes_audited / 60)

n.reg.users.removed <- zoning.data %>% filter(exclude) %>% distinct(condition.id) %>% nrow()
```

Below is a table showing number of ground truth labels by user group and by label type.

```{r turk.showing.stats.1, echo=FALSE}
gt.count.data <-
  data.with.raw.accuracy %>%
  filter(worker.type %in% c('anon', 'reg'),
         binary == FALSE,
         included.severity == 'all',
         granularity == 'street',
         label.type != 'AllProb') %>%
  group_by(worker.type, label.type) %>%
  summarize(gt.labels = sum(true.pos, false.neg)) %>%
  ungroup() %>%
  mutate(worker.type = as.character(worker.type))

gt.count.totals <-
  gt.count.data %>%
  group_by(label.type) %>%
  summarize(gt.labels = sum(gt.labels)) %>%
  mutate(worker.type = 'total')

n.gt <- gt.count.totals %>% filter(label.type == 'All') %>% select(gt.labels) %>% as.numeric()

gt.count.percentages <-
  gt.count.totals %>%
  mutate(gt.labels = paste0(format(100 * gt.labels / n.gt, digits = 2), '%'),
         worker.type = '% of total')
  
table.levels <- c('anon', 'reg', 'total', '% of total')
kable(bind_rows(gt.count.data %>% mutate(gt.labels = as.character(gt.labels)),
                gt.count.totals %>% mutate(gt.labels = as.character(gt.labels)),
                gt.count.percentages) %>%
        mutate(worker.type = factor(worker.type, levels = table.levels, labels = table.levels)) %>%
        spread(label.type, gt.labels),
  format = 'markdown',
  digits = 3,
  align = 'l'
  )
```

A total of `r n.turkers` turkers, `r n.reg` registered users, and `r n.anon` anonymous users were part of this study.


### Aggregate accuracy

Below are two tables (street level, then 5 meter level) showing average (median) accuracy across all users when aggregating over all label types, and for problem vs no problem. We see that the accuracies are comparable at the street level, but accuracy is much higher for curb ramps than problems at the 5 meter level.

NOTE: In these two tables, the data is binary (not ordinal), we are only considering single users auditing (i.e., no multi-user clustering or majority vote), and we only consider the first turker to audit each route.

Median accuracy across all users - street level:

```{r turk.showing.stats.2, echo=FALSE}
kable(
  aggregate.accuracy.data %>%
    filter(granularity == 'street') %>%
    select(-granularity),
  format = 'markdown',
  digits = 3,
  align = 'l'
  )
```

Median accuracy across all users - 5 meter level:

```{r turk.showing.stats.3, echo=FALSE}
kable(
  aggregate.accuracy.data %>%
    filter(granularity == '5_meter') %>%
    select(-granularity),
  digits = 3,
  align = 'l'
  )
```


### Accuracy by user group

Then we show the above accuracy measures (but for only precision, recall, and f-measure), as an average (median) per user group. These are again as an aggregate across all label types (all.\*) and for the problem vs no problem type (prob.\*).

NOTE: In these two tables, the data is binary (not ordinal).

Median accuracy by user group - street level:

```{r turk.showing.stats.4, echo=FALSE}
turk.showing.stats.4.and.5 <- 
  turk.study.summary.stats %>%
    group_by(worker.type, granularity) %>%
    dplyr::summarize(
      all.recall = median(all.recall, na.rm = TRUE),
      all.prec = median(all.precision, na.rm = TRUE),
      all.f.meas = median(all.f.measure, na.rm = TRUE),
      prob.recall = median(prob.recall, na.rm = TRUE),
      prob.prec = median(prob.precision, na.rm = TRUE),
      prob.f.meas = median(prob.f.measure, na.rm = TRUE)
    ) %>%
    dplyr::rename(user.type = worker.type)

kable(
  turk.showing.stats.4.and.5 %>%
    filter(granularity == 'street') %>%
    select(-granularity),
  digits = 3,
  align = 'l'
  )
```

Median accuracy by user group - 5 meter level:

```{r turk.showing.stats.5, echo=FALSE}
kable(
  turk.showing.stats.4.and.5 %>%
    filter(granularity == '5_meter') %>%
    select(-granularity),
  digits = 3,
  align = 'l'
  )
```


### Accuracy by label type

Then we show the above accuracy measures (but for only precision, recall, and f-measure), as an average (median) per label type. This is done at the street level and 5 meter levels.

NOTE: In the two tables below, the data are binary (not ordinal), we are only considering single users auditing (i.e., no multi-user clustering or majority vote), and we only consider the first turker to audit each route.

Median accuracy by label type - street level:

```{r turk.showing.stats.by.label.type.1, echo=FALSE}
turk.showing.stats.by.label.type <-
  data.with.raw.accuracy %>%
  filter(binary == TRUE, n.workers == 1, included.severity == 'all', label.type != 'AllProb')

kable(
  turk.showing.stats.by.label.type %>%
    filter(granularity == 'street') %>%
    group_by(label.type) %>%
    summarize_at(vars(recall, precision, f.measure), median, na.rm = TRUE),
  digits = 3,
  align = 'l'
  )
```

Median accuracy by label type - 5 meter level:

```{r turk.showing.stats.by.label.type.2, echo=FALSE}
kable(
  turk.showing.stats.by.label.type %>%
    filter(granularity == '5_meter') %>%
    group_by(label.type) %>%
    summarize_at(vars(recall, precision, f.measure), median, na.rm = TRUE),
  digits = 3,
  align = 'l'
  )
```


### Voting: Improved recall when at least one turker marks

```{r turk.voting.method.setup, echo=FALSE}
voting.method.data <-
  data.with.raw.accuracy %>%
  filter(label.type %in% c('All', 'Problem'),
         n.workers == 5 | worker.type == 'reg',
         binary == TRUE,
         granularity == 'street',
         label.type == 'Problem',
         included.severity == 'all',
         worker.thresh %in% c(1,3)) %>%
  mutate(voting.method = factor(if_else(worker.thresh == 1,
                                        'at.least.one',
                                        'majority.vote'))) %>%
  group_by(worker.type, voting.method, label.type, granularity) %>%
  dplyr::summarize_at(vars(recall, precision), median, na.rm = TRUE) %>%
  ungroup()

# Get registered user recall to compare to
reg.recall <-
  voting.method.data %>%
  filter(worker.type == 'reg') %>%
  select(recall) %>%
  as.numeric() %>%
  format(digits = 2)
reg.precision <-
  voting.method.data %>%
  filter(worker.type == 'reg') %>%
  select(precision) %>%
  as.numeric() %>%
  format(digits = 2)
```


Since dealing with false positives is pretty easy (relative to walking through GSV), the most important thing for us is to maximize recall. So how does recall look if we consider a label placed by at least one turker as a potential attribute (i.e., we use the "at least one" voting method)?

For reference, registered users tended to have the best performance among our user groups, and their recall for problem vs no problem was `r reg.recall` and their precision was `r reg.precision`.

NOTE: In this section we are looking at _problem vs no problem_, the data are binary (not ordinal), the data are at the street level (not 5 meter level), and we are looking at 5 clustered turkers with the "at least one" voting method.

*Takeaways*:

* The median recall is actually perfect for street level when using this other voting method, and the precision is still at 0.67, which isn't bad at all! This actually gives 5 turkers higher recall than registered users, and their precision is equal.

* It would be interesting to see what this looks like at the 5 meter level as well.

```{r turk.voting.method.analysis, echo=FALSE}
kable(
  voting.method.data %>%
    filter(worker.type != 'reg') %>%
    select(voting.method, recall, precision),
  digits = 3,
  align = 'l'
)
```


### Descriptive stats for users

Next we have some descriptive statistics of users, by user group. These are average (median) stats.

NOTE: In this table, we are only considering single users auditing (i.e., no multi-user clustering or majority vote), and we only consider the first turker to audit each route.

```{r turk.showing.stats.6, echo=FALSE}
kable(
  turk.study.summary.stats.with.labels %>%
    filter(granularity == 'street') %>%  # granularity doesn't affect these stats
    group_by(worker.type) %>%
    dplyr::summarize(
      labels.per.100m = median(labels.per.100m, na.rm = TRUE),
      km.per.hr = median(km.per.hr, na.rm = TRUE),
      m.per.min = median(meters.per.min, na.rm = TRUE),
      minutes.per.1k.ft = median(minutes.per.1k.ft, na.rm = TRUE),
      minutes_audited = median(minutes_audited, na.rm = TRUE)
    ),
  digits = 3,
  align = 'l'
  )
```


Below, we have a table of aggregate (sum) stats by user group.

NOTE: In this table, we are only considering single users auditing (i.e., no multi-user clustering or majority vote), and we only consider the first turker to audit each route.

```{r turk.showing.stats.7, echo=FALSE}
kable(
  turk.study.summary.stats.with.labels %>%
    filter(granularity == 'street') %>%  # granularity doesn't affect these stats
    group_by(worker.type) %>%
    dplyr::summarize(
      n.missions = sum(n.missions, na.rm = TRUE),
      distance.feet = sum(distance.feet, na.rm = TRUE),
      n.labels = sum(n.labels, na.rm = TRUE),
      hours.audited = sum(hours.audited, na.rm = TRUE)
    ) %>%
    mutate(distance.miles = distance.feet / 5280,
           distance.km = distance.feet / 3280.84) %>%
    select(worker.type, n.missions, distance.miles, distance.km, n.labels, hours.audited),
  digits = 3,
  align = 'l'
  )
```


### IRR

Our average (mean) IRR over the 7 rounds, by label type, is in the table below:

NOTE: In this table, the data is binary (not ordinal), and is at the street level (not 5 meter level).

```{r turk.irr.stats, echo=FALSE}
kable(
  clean.agreement.data %>%
    group_by(label.type) %>%
    dplyr::summarize(mean.kripp.alpha = mean(kripp.alpha)),
  digits = 3,
  align = 'l'
  )
```


### Zone types


Here is the zone type distribution for the mturk study. This shows the distribution of zone type for the routes that we took from anonymous and registered users and compare it to the distribution across all of DC. There are three zone types where anonymous users have no data, but registered users do. So the second graph shows the distribution when we remove the sets of routes from registered users the contain data from those three zone types. We will likely use the second set of data for comparison between the user groups. This removes `r n.reg.users.removed` of the `r n.reg` sets of routes from registered users. There is still `r n.anon` sets of routes from anonymous users.

```{r turk.zone.type.distribution, echo=FALSE, fig.width=4.5, fig.height=4}
zoning.with.volunteer.type <-
  data.with.raw.accuracy %>%
  select(condition.id, is.anon.route) %>%
  distinct() %>%
  inner_join(zoning.data, by = 'condition.id') %>%
  mutate(volunteer.type = factor(is.anon.route,
                                 levels = c(FALSE, TRUE),
                                 labels = c('Registered', 'Anonymous'))) %>%
  mutate(zone.type = fct_recode(zone_type,
                                'Downtown'           = 'Downtown Zone',
                                'Mixed-Use'          = 'Mixed-Use Zone',
                                'Nbhd Mixed-Use'     = 'Neighborhood Mixed-Use Zone',
                                'Prod,Distro,Repair' = 'Production, Distribution, and Repair Zone',
                                'Residential Apt'    = 'Residential Apartment Zone',
                                'Residential Flat'   = 'Residential Flat Zone',
                                'Residential'        = 'Residential Zone',
                                'Special Purpose'    = 'Special Purpose Zone'))

all.dc.zoning.data <- data_frame(
  volunteer.type = c('All Streets'),
  zone.type = c('Downtown',
                'Mixed-Use',
                'Nbhd Mixed-Use',
                'Prod,Distro,Repair',
                'Residential Apt',
                'Residential Flat',
                'Residential',
                'Special Purpose',
                'Unzoned'),
  percent.of.streets = c(5.74, 11.73, 1.02, 2.47, 14.82, 15.01, 42.89, 1.30, 5.03)
)

land.use.by.volunteer.type <-
  zoning.with.volunteer.type %>%
  group_by(volunteer.type, zone.type) %>%
  dplyr::summarize(n.streets = n()) %>%
  complete(zone.type, fill = list(n.streets = 0)) %>%
  mutate(percent.of.streets = 100 * n.streets / sum(n.streets)) %>%
  ungroup() %>%
  select(volunteer.type, zone.type, percent.of.streets) %>%
  rbind(all.dc.zoning.data)

land.use.by.volunteer.type.filtered <-
  zoning.with.volunteer.type %>%
  filter(!exclude) %>%
  group_by(volunteer.type, zone.type) %>%
  dplyr::summarize(n.streets = n()) %>%
  mutate(percent.of.streets = 100 * n.streets / sum(n.streets)) %>%
  ungroup() %>%
  select(volunteer.type, zone.type, percent.of.streets) %>%
  rbind(all.dc.zoning.data) %>%
  filter(!(zone.type %in% c('Nbhd Mixed-Use', 'Special Purpose', 'Unzoned')))

ggplot(data = land.use.by.volunteer.type, aes(x = zone.type, y = percent.of.streets, fill = volunteer.type)) +
  geom_col(position = 'dodge') +
  my.theme.discrete.x +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) +
  scale_y_continuous(expand = c(0.01, 0)) # removes weird white space at bottom of plot

ggplot(data = land.use.by.volunteer.type.filtered, aes(x = zone.type, y = percent.of.streets, fill = volunteer.type)) +
  geom_col(position = 'dodge') +
  my.theme.discrete.x +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) +
  scale_y_continuous(expand = c(0.01, 0)) # removes weird white space at bottom of plot
```

## Possible Stories

### Granularity: Street-level vs 5 meter-level

Below we compare street vs 5 meter level recall and precision by label type.

NOTE: In this section, the data is binary (not ordinal), we are only considering single users auditing (i.e., no multi-user clustering or majority vote), and we only consider the first turker to audit each route.

NOTE: This is a rare case where we are using the mean, since we are also showing standard error at the same time.

```{r turk.granularity.analysis, echo=FALSE, fig.width=7, fig.height=4}
granularity.analysis.data <-
  data.with.raw.accuracy %>%
  filter(included.severity == 'all',
         binary == TRUE,
         n.workers == 1,
         label.type %in% LABEL_TYPES_TO_ANALYZE) %>%
  gather(accuracy.type, accuracy.value, recall, precision, na.rm = TRUE, factor_key = TRUE)

# Make the set of labels that give the number of observations for each sub-graph.
granularity.analysis.labels <-
  granularity.analysis.data %>%
  group_by(label.type, accuracy.type, granularity) %>%
  dplyr::summarize(n = sum(!is.na(accuracy.value))) %>%
  dplyr::summarize(n_label = paste0('n = (',
                                    first(n[granularity == '5_meter']), ',',
                                    first(n[granularity == 'street']),
                                    ')')) %>%
  ungroup()

granularity.analysis.summary <-
  granularity.analysis.data %>%
  group_by(label.type, accuracy.type, granularity) %>%
  dplyr::summarize(se = sd(accuracy.value, na.rm = TRUE) / sqrt(n()),
                   accuracy.value = mean(accuracy.value, na.rm = TRUE),
                   error.bar.min = max(0, accuracy.value - se),
                   error.bar.max = min(1, accuracy.value + se))

ggplot(data = granularity.analysis.summary, aes(x = label.type, y = accuracy.value)) +
  geom_col(aes(fill = granularity), position = position_dodge()) +
  geom_errorbar(aes(ymin = error.bar.min, ymax = error.bar.max, group = granularity),
                width = 0.25, position = position_dodge(0.9)) +
  scale_y_continuous(breaks = ACCURACY_BREAKS, limits = c(0, 1.0), expand = c(0.01, 0)) +
  facet_grid(accuracy.type ~ .) +
  ggtitle('Street vs. 5 Meter level Granularity') +
  my.theme.discrete.x
  # theme(axis.text.x = element_text(angle = 40, hjust = 1, vjust = 1))
```

*Takeaways*:

* Analyzing at the 5 meter level shows higher raw accuracy and specificity, both because of the large number of true negatives that we get from splitting into 5 meter segments; there are very few street segments with no labels at all.

* Analyzing at the street level shows higher recall, implying that there were relatively fewer false negatives at the street level. This may mean that users aren't finding _every_ issue, but they are more likely to find _at least one_ issue of that type when there are multiple that occur on the same street.

* Analyzing at the street level shows higher precision, implying that there were relatively fewer false positives at the street level. I suspect that this is due to fundamental misunderstandings about how to label (implying both that labeling is complex and difficult and that our onboarding is insufficient) which are persistent/consistent and frequent (think: labeling driveways as curb ramps, labeling storm drains as missing curb ramps, and labeling fire hydrants or street signs that are not in the way as obstacles). In those cases where the mistake is made frequently (multiple times per street), relatively fewer false positives makes sense when moving to street level analysis.

* Analyzing at the street level shows higher f-measure. This clearly comes from the higher recall and precision.

* CurbRamp pretty much outperforms all other label types across the board, regardless of accuracy type of 5 meter vs. street level. This is likely because curb ramps are the easiest label type to understand and find in GSV (both because they are large and easy to see, and because you know where to expect them -- at intersections).

* The SurfaceProblem label type seems to have the highest precision and lowest recall among the different types of issues (I'm excluding CurbRamp here). I guess that, relative to the other types of issues, there are just fewer cases of mistaking something of a surface problem and more cases of not finding a surface problem that was visible in GSV (so maybe surface problems require increased diligence from users, and the other issues require better treatment in onboarding).

* The Problem type seems to perform better than the surface problem and obstacle label types (except for surface problem precision, mentioned in the previous bullet).

* NoCurbRamp seems to have high recall and low precision. This fits my intuition; since users know to expect curb ramps at intersections, if they arrive at an intersection and a curb ramp is not there, they know to place a NoCurbRamp label. However, if there was no sidewalk at all, then we did not add the missing curb ramp labels to the ground truth dataset, and this is not something that we covered during onboarding. I suspect that this, paired with users marking storm drains as missing curb ramps, were the main reasons for the low recall. Both could be addressed through proper training.


### Zone type: Land use effect on accuracy

The first graph shows all label types aggregated, the second shows the problem vs. no problem type.

NOTE: In this section, the data is binary (not ordinal), and is at the street level (not 5 meter level), we are only considering single users auditing (i.e., no multi-user clustering or majority vote), and we only consider the first turker to audit each route.

NOTE: The red dots on the graphs are means.

*Takeaways*:

```{r turk.zone.type.analysis, echo=FALSE, fig.width=4.5, fig.height=4}
condition.land.use <-
  zoning.with.volunteer.type %>%
  group_by(condition.id) %>%
  count(zone.type) %>%
  slice(which.max(n))

zone.type.analysis.data <-
  data.with.raw.accuracy %>%
  inner_join(condition.land.use, by = 'condition.id') %>%
  filter(binary == TRUE,
         granularity == 'street',
         included.severity == 'all',
         n.workers == 1,
         label.type %in% c('All', 'Problem')) %>%
  gather(accuracy.type, accuracy.value, recall, precision, na.rm = TRUE, factor_key = TRUE)

# Create the trellis boxplots.
ggplot(data = zone.type.analysis.data %>% filter(label.type == 'All'),
       aes(x = zone.type, y = accuracy.value)) +
  geom_boxplot() +
  stat_summary(fun.y = mean, geom = 'point', color = 'red', size = 1) +
  facet_grid(accuracy.type ~ .) +
  ggtitle('Zone Type Accuracy Across All Label Types') +
  my.theme.discrete.x +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) +
  scale_y_continuous(expand = c(0.01, 0)) # removes weird white space at bottom of plot

ggplot(data = zone.type.analysis.data %>% filter(label.type == 'Problem'),
       aes(x = zone.type, y = accuracy.value)) +
  geom_boxplot() +
  stat_summary(fun.y = mean, geom = 'point', color = 'red', size = 1) +
  facet_grid(accuracy.type ~ .) +
  ggtitle('Zone Type Accuracy for Problem vs. NoProblem') +
  my.theme.discrete.x +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) +
  scale_y_continuous(expand = c(0.01, 0)) # removes weird white space at bottom of plot
```


### User behavior: Does auditing speed, etc influence accuracy

```{r turk.user.behavior.setup, echo=FALSE}
turk.behavior.data <-
  data.with.raw.accuracy %>%
  filter(worker.type %in% c('anon', 'reg', 'turk1'),
         binary == TRUE,
         included.severity == 'all',
         granularity == 'street') %>%
  left_join(labels.turk.study, by = c('worker1' = 'user_id', 'condition.id' = 'condition_id')) %>%
  group_by_at(vars(condition.id:raw.accuracy)) %>%
  dplyr::summarise(n.labels = n_distinct(label_id, na.rm = TRUE)) %>%
  ungroup() %>%
  left_join(times.turk.study, by = c('worker1' = 'user_id')) %>%
  mutate(n.missions = if_else(is.anon.route, 2, 3),
         distance.feet = if_else(is.anon.route, 2000, 4000),
         distance.meters = distance.feet / 3.28084,
         labels.per.100m = 100 * n.labels / distance.meters,
         meters.per.min = distance.meters / minutes_audited,
         km.per.hr = 60 * meters.per.min / 1000,
         minutes.per.1k.ft = 1000 * minutes_audited / distance.feet,
         hours.audited = minutes_audited / 60) %>%
  gather(key = accuracy.type, value = accuracy.value, recall, precision, f.measure) %>%
  mutate(accuracy.type = factor(accuracy.type, levels = c('recall', 'precision', 'f.measure'))) %>%
  filter(label.type %in% c('All', 'Problem'))

meters.per.min.threshold <- 100
test1 <-
  turk.behavior.data %>%
    filter(accuracy.type == 'recall', label.type == 'All') %>%
    dplyr::summarise(n.above.threshold = sum(meters.per.min >= meters.per.min.threshold),
                     n = n())
n.above.thresh <- as.numeric(test1$n.above.threshold)
n.total <- as.numeric(test1$n)
percent.above.thresh <- format(100 * n.above.thresh / n.total, digits = 2)
max.speed <- format(max(turk.behavior.data$meters.per.min), digits = 2)
```


Below we investigate how user behavior is associated with performance in our turk study. The graphs below are more exploratory. I am not sure that we can be guaranteed any statistical significance by simply looking at the graphs below. We can always formulate hypothesis tests once we narrow down what we want to look at.

NOTE: In this section, the data are binary (not ordinal), at the street level granularity (not 5 meter level) we are only considering single users auditing (i.e., no multi-user clustering or majority vote), and we only consider the first turker to audit each route.

For the second graph, we are only looking at users with a speed of less than `r meters.per.min.threshold` meters per minute, because only `r n.above.thresh` users (`r percent.above.thresh`%) had speeds higher than that. The max speed was `r max.speed` meters per minute.

```{r turk.user.behavior.analysis, echo=FALSE, fig.width=4.5, fig.height=5}
ggplot(data = turk.behavior.data, aes(x = labels.per.100m, y = accuracy.value)) +
  geom_point(na.rm = TRUE) +
  geom_smooth(method = 'loess', na.rm = TRUE, fullrange = TRUE) +
  facet_grid(accuracy.type ~ label.type, switch = 'x') +
  scale_x_continuous(expand = c(0.01, 0)) +
  scale_y_continuous(limits = c(-0.5, 1.5), breaks = ACCURACY_BREAKS, expand = c(0.025, 0)) +
  coord_cartesian(ylim = c(0, 1)) +
  theme_bw()

ggplot(data = turk.behavior.data %>% filter(meters.per.min < meters.per.min.threshold),
       mapping = aes(x = meters.per.min, y = accuracy.value)) +
  geom_point(na.rm = TRUE) +
  geom_smooth(method = 'loess', na.rm = TRUE, fullrange = TRUE) +
  facet_grid(accuracy.type ~ label.type, switch = 'x') +
  scale_x_continuous(expand = c(0.01, 0)) +
  scale_y_continuous(limits = c(-0.5, 1.5), breaks = ACCURACY_BREAKS, expand = c(0.025, 0)) +
  coord_cartesian(ylim = c(0, 1)) +
  theme_bw()
```


*Takeaways*:

* Labeling frequency seems to have a positive relationship with recall, which is what we would have expected.

* Labeling frequency seems to have a more positive relationship with the Problem (vs no problem) type than for the all label types combined (at least for the highest labeling frequencies, greater than 15 labels per 100m). I would think that, for the highest labeling frequencies, this comes from users who are labeling driveways as curb ramps. This would hurt their curb ramp precision, but not Problem type precision.

* Auditing speed did not seem to have a big impact on performance by itself.

### User group: Reg vs anon vs turk1 vs turk3 vs turk5

TODO: Make some graphs.

*Takeaways*:


```{r turk.user.group.analysis, echo=FALSE, fig.width=8, fig.height=6}
```


### Low severity: Removing low severity effect on recall

Below is a table with counts of ground truth labels in the dataset at different severity thresholds. This is followed by a trellis plot that shows how recall changes when we remove low severity problems from the ground truth dataset. This is shown by label type and user group.

NOTE: In this section, the data is binary (not ordinal), and is at the street level (not 5 meter level).

*Takeaways*:

* Only 17% of surface problems and 35% of obstacles had severity of 3 or higher. Most missing curb ramps are high severity (not surprising).

* The general trend is a decent improvement in recall when we remove high severity labels from the ground truth.

* Note that it _is_ possible for the recall to get worse when removing high severity labels. This is because certain users may have found more of the low severity problems than the high severity ones.


```{r turk.high.severity.analysis, echo=FALSE, fig.width=8, fig.height=6}
low.severity.check.data <-
  data.with.raw.accuracy %>%
  filter(included.severity %in% c('all', '<=2', '>=3'),
         label.type == 'Problem',
         worker.type %in% c('reg', 'anon', 'turk1'),
         granularity == 'street') %>%
  droplevels %>%
  mutate(included.severity = factor(included.severity,
                                    labels = c('all', '<=2', '>=3'),
                                    levels = c('all', '<=2', '>=3')))

recall.by.severity <-
  low.severity.check.data %>%
  filter(binary == TRUE) %>%
  group_by(included.severity) %>%
  summarize(mean.recall = mean(recall, na.rm = TRUE),
            median.recall = median(recall, na.rm = TRUE))

gt.counts.by.severity <-
  low.severity.check.data %>%
  filter(worker.type == 'turk1',
         binary == FALSE) %>%
  group_by(included.severity) %>%
  summarize(gt.problem.labels = sum(true.pos, false.neg))

kable(
  inner_join(gt.counts.by.severity, recall.by.severity, by = 'included.severity'),
  format = 'markdown',
  digits = 3,
  align = 'l'
  )
```


### Binary vs ordinal issues per segment

For simplicity, the first graph looks at the 5 meter level, and the second looks at street level. All user groups are also combined (the groups being: registered volunteers, anonymous volunteers, and individual turkers).

NOTE: In this section, the data is at the street level (not 5 meter level), we are only considering single users auditing (i.e., no multi-user clustering or majority vote), and we only consider the first turker to audit each route.

NOTE: The red dots on the graphs are means.

*Takeaways*:

* 5 meter level (first graph): Considering multiple issues per segment results in _very slightly_ lower accuracy for pretty much every type of label and type of accuracy (except precision). I suspect that this comes mostly from our method of clustering, which makes it unlikely that users end up with multiple labels per 5 meter segment. We do not have this restriction in the ground truth, so those few cases where we have more than one label per 5 meter segment in the GT usually results in an additional false negative when moving to ordinal analysis. However, the difference here is very small, so our clustering method seems fine to me.

* Street level (second graph) recall: If we do this analysis at the street level, the decreases in accuracy are more pronounced. At this level, the clustering shouldn't have much effect. The decrease in recall suggests that users are finding _some_ of the problems, but not _all_ of them (meaning an increase in false negatives when we move to ordinal analysis).

* Street level (second graph) recall: I suspect that the reason for the decrease in precision when moving to ordinal analysis at the street level is the same reason as why 5 meter level has lower precision than street level (seen in the previous section). That is, users' misunderstandings of how to label certain common things (driveways as curb ramps, etc.); since these mistakes are common, they may happen many times on a single street edge, which means that you start racking up the false positives when you move to ordinal analysis.


```{r turk.issues.per.seg.analysis, echo=FALSE, fig.width=8, fig.height=4}
issues.per.seg.analysis.data <-
  data.with.raw.accuracy %>%
  filter(included.severity == 'all',
         n.workers == 1,
         label.type %in% LABEL_TYPES_TO_ANALYZE) %>%
  mutate(issues.per.segment = factor(if_else(binary, 'binary', 'ordinal'))) %>%
  gather(accuracy.type, accuracy.value, recall, precision, na.rm = TRUE, factor_key = TRUE)

# Make the set of labels that give the number of observations for each sub-graph.
issues.per.seg.analysis.labels <-
  issues.per.seg.analysis.data %>%
  group_by(label.type, accuracy.type, granularity, issues.per.segment) %>%
  dplyr::summarize(n = sum(!is.na(accuracy.value))) %>%
  dplyr::summarize(n_label = paste0('n = (',
                                    first(n[issues.per.segment == 'binary']), ',',
                                    first(n[issues.per.segment == 'ordinal']),
                                    ')')) %>%
  ungroup()

# Create the trellis boxplots.
ggplot(data = issues.per.seg.analysis.data %>% filter(granularity == '5_meter'),
       aes(x = issues.per.segment, y = accuracy.value)) +
  geom_boxplot() +
  stat_summary(fun.y = mean, geom = 'point', color = 'red', size = 1) +
  scale_y_continuous(breaks = ACCURACY_BREAKS, limits = c(0, 1.15)) +
  geom_hline(aes(yintercept = 1.0), linetype = 'dotted') +
  geom_text(data = issues.per.seg.analysis.labels %>% filter(granularity == '5_meter'),
             mapping = aes(x = -Inf, y = 1.13, hjust = 'inward', label = n_label), size = 3.5) +
  facet_grid(accuracy.type ~ label.type) +
  ggtitle('5 Meter-Level Analysis of Issues per Segment') +
  my.theme.discrete.x

ggplot(data = issues.per.seg.analysis.data %>% filter(granularity == 'street'),
       aes(x = issues.per.segment, y = accuracy.value)) +
  geom_boxplot() +
  stat_summary(fun.y = mean, geom = 'point', color = 'red', size = 1) +
  scale_y_continuous(breaks = ACCURACY_BREAKS, limits = c(0, 1.15)) +
  geom_hline(aes(yintercept = 1.0), linetype = 'dotted') +
  geom_text(data = issues.per.seg.analysis.labels %>% filter(granularity == 'street'),
             mapping = aes(x = -Inf, y = 1.13, hjust = 'inward', label = n_label), size = 3.5) +
  facet_grid(accuracy.type ~ label.type) +
  ggtitle('Street-Level Analysis of Issues per Segment') +
  my.theme.discrete.x
```
